
#include <arduinoFFT.h>
#include <WiFi.h>
#include <esp_now.h>

#define SAMPLES         512          // Must be a power of 2
#define SAMPLING_FREQ   30000         // Hz, must be 40000 or less due to ADC conversion time. Determines maximum frequency that can be analysed by the FFT Fmax=sampleF/2.
#define AMPLITUDE       1            // Depending on your audio source level, you may need to alter this value. Can be used as a 'sensitivity' control.
#define AUDIO_IN_PIN    0            // Signal in on this pin
#define NUM_BANDS       6            // To change this, you will need to change the bunch of if statements describing the mapping from bins to bands
#define NOISE           1000           // Used as a crude noise filter, values below this are ignored

#define BAND1_PIN       1
#define BAND2_PIN       2
#define BAND3_PIN       21
#define BAND4_PIN       22
#define BAND5_PIN       23
#define BAND6_PIN       16

#define RUN_AVG_N       4

// Sampling and FFT stuff
unsigned int sampling_period_us;
int peak[] = {1,1,1,1,1,1};              // The length of these arrays must be >= NUM_BANDS
int bandValues[] = {0,0,0,0,0,0};
double vReal[SAMPLES];
double vImag[SAMPLES];
unsigned long newTime;
ArduinoFFT<double> FFT(vReal, vImag, SAMPLES, SAMPLING_FREQ);

/*
//Wifi stuff
uint8_t broadcastAddress[] = {0xb8, 0xf8, 0x62, 0xd5, 0xcd, 0x24};

//Struct for WiFi communication
typedef struct struct_message {
  float band1, band2, band3, band4, band5, band6;
} struct_message;

//Message to hold band data to transmit
struct_message outBands;

esp_now_peer_info_t peerInfo;

// Callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
*/

void setup() {
  Serial.begin(115200);
  sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQ));

  pinMode(BAND1_PIN, OUTPUT);
  pinMode(BAND2_PIN, OUTPUT);
  pinMode(BAND3_PIN, OUTPUT);
  pinMode(BAND4_PIN, OUTPUT);
  pinMode(BAND5_PIN, OUTPUT);
  pinMode(BAND6_PIN, OUTPUT);

/*
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Transmitted packet
  esp_now_register_send_cb(esp_now_send_cb_t(OnDataSent));
  
  // Register peer
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  
  // Add peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
*/
}

void loop() {

  // Reset bandValues[]
  for (int i = 0; i<NUM_BANDS; i++){
    bandValues[i] = 0;
  }

  // Sample the audio pin
  for (int i = 0; i < SAMPLES; i++) {
    newTime = micros();
    vReal[i] = analogRead(AUDIO_IN_PIN); // A conversion takes about 9.7uS on an ESP32
    vImag[i] = 0;
    while ((micros() - newTime) < sampling_period_us) { /* chill */ }
  }

  // Compute FFT
  FFT.dcRemoval();
  FFT.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.compute(FFT_FORWARD);
  FFT.complexToMagnitude();

  // Analyse FFT results
  for (int i = 2; i < (SAMPLES/2); i++){       // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
    if (vReal[i] > NOISE) {                    // Add a crude noise filter
      if (i <= 2)             bandValues[0] += (int)vReal[i];
      else if (i <= 6)        bandValues[1] += (int)vReal[i];
      else if (i <= 12)       bandValues[2] += (int)vReal[i];
      else if (i <= 40)       bandValues[3] += (int)vReal[i];
      else if (i <= 100)      bandValues[4] += (int)vReal[i];
      else                    bandValues[5] += (int)vReal[i];
    } 
  }

/*
  outBands.band1 = bandValues[0];
  outBands.band2 = bandValues[1];
  outBands.band3 = bandValues[2];
  outBands.band4 = bandValues[3];
  outBands.band5 = bandValues[4];
  outBands.band6 = bandValues[5];
*/

  for (int i = 0; i < NUM_BANDS; i++){
    if(bandValues[i] > peak[i])
    {
      peak[i] = bandValues[i];
    }
    bandValues[i] / peak[i];
  }

  analogWrite(BAND1_PIN, 255 * bandValues[0] / peak[0]);
  analogWrite(BAND2_PIN, 255 * bandValues[1] / peak[1]);
  analogWrite(BAND3_PIN, 255 * bandValues[2] / peak[2]);
  analogWrite(BAND4_PIN, 255 * bandValues[3] / peak[3]);
  analogWrite(BAND5_PIN, 255 * bandValues[4] / peak[4]);
  analogWrite(BAND6_PIN, 255 * bandValues[5] / peak[5]);

  Serial.print(bandValues[0]); Serial.print(", "); 
  Serial.print(bandValues[1]); Serial.print(", ");
  Serial.print(bandValues[2]); Serial.print(", ");
  Serial.print(bandValues[3]); Serial.print(", ");
  Serial.print(bandValues[4]); Serial.print(", "); 
  Serial.print(bandValues[5]); Serial.println("; ");

  //esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &outBands, sizeof(outBands));
}
